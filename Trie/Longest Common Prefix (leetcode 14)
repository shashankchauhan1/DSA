// java

class Node{
    Node[] links;
    boolean flag;

    Node(){
        links = new Node[26];
        flag = false;
    }

    boolean containsKey(char ch){
        return links[ch-'a']!=null;
    }
    
    void put(char ch){
        links[ch-'a'] = new Node();
    }

    Node get(char ch){
        return links[ch-'a'];
    }

    void setEnd(){
        flag = true;
    }

    boolean isEnd(){
        return flag;
    }
}

class Trie{
    Node root;

    Trie(){
        root = new Node();
    }

    void insert(String word){
        Node node = root;
        for(int i=0; i<word.length(); i++){
            char ch = word.charAt(i);
            if(!node.containsKey(ch)) node.put(ch);
            node = node.get(ch);
        }
        node.setEnd();
    }

    String find(){
        StringBuilder sb = new StringBuilder();
        Node node = root;
        
        // go only till then where there is only character else as soon the trie splits means prefix ends
        while(true){
            int count = 0;
            int index = -1;
            for(int i=0; i<26; i++){
                if(node.links[i]!=null){
                    count++;
                    index = i;
                }
            }

            if(count!=1 || node.isEnd()) break;

            sb.append((char)(index+'a'));
            node = node.links[index];
        }

        return sb.toString();
    }

}

class Solution {
    public String longestCommonPrefix(String[] strs) {
        Trie trie = new Trie();
        for(String str : strs) trie.insert(str);
        String ans = trie.find();

        return ans;
    }
}
