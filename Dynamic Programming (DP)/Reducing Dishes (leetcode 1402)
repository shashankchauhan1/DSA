// java

// Recursion

class Solution {
    public int f(int i,int time,int[] sat){
        if(i==sat.length) return 0;

        int pick = sat[i]*time + f(i+1,time+1,sat);
        int notpick = f(i+1,time,sat);

        return Math.max(pick,notpick);
    }

    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        
        int ans = f(0,1,satisfaction);

        return Math.max(0,ans);
    }
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Memoization

class Solution {
    public int f(int i,int time,int[] sat,Integer[][] dp){
        if(i==sat.length) return 0;

        if(dp[i][time]!=null) return dp[i][time];

        int pick = sat[i]*time + f(i+1,time+1,sat,dp);
        int notpick = f(i+1,time,sat,dp);

        return dp[i][time] = Math.max(pick,notpick);
    }

    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        int n = satisfaction.length;
        Integer[][] dp = new Integer[n][n+1];
        int ans = f(0,1,satisfaction,dp);

        return Math.max(0,ans);
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Tabulation

class Solution {
    public int maxSatisfaction(int[] satisfaction) {
        Arrays.sort(satisfaction);
        int n = satisfaction.length;

        int[][] dp = new int[n+1][n+2];
        for(int i=n-1; i>=0; i--){
            for(int time=n; time>=1; time--){
                int pick = satisfaction[i]*time + dp[i+1][time+1];
                int notpick = dp[i+1][time];
                dp[i][time] = Math.max(pick,notpick);
            }
        }

        return Math.max(0,dp[0][1]);
    }
}
