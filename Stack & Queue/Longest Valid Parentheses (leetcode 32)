// java

1> Optimal Approach O(n)

class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st=new Stack<>();
        st.push(-1);
        int maxlen=0;
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i)=='(') st.push(i);
            else{
                st.pop();
                if(st.isEmpty()){
                    st.push(i);
                }
                else{
                    maxlen=Math.max(maxlen,i-st.peek());
                }
            }
        }
        return maxlen;
    }
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2> O(Nlogn)

class Pair{
    int first;
    int second;
    Pair(int f,int s){
        this.first=f;
        this.second=s;
    }
}

class Solution {
    public int longestValidParentheses(String s) {
        if(s.length()<=1) return 0;
        Stack<Pair> st=new Stack<>();
        
        ArrayList<Integer> list=new ArrayList<>();
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i)=='(') st.push(new Pair(s.charAt(i),i));
            else if(!st.isEmpty() && s.charAt(i)==')' && st.peek().first=='('){
                Pair p=st.pop();
                list.add(p.second);
                list.add(i);
            }
        }

        Collections.sort(list);
        int count=1;
        boolean boolCountCheck=false;
        int maxCount=-1;
        for(int i=1; i<list.size(); i++){
            if(list.get(i)-list.get(i-1)==1){
                boolCountCheck=true;
                count++;
            }
            else{
                maxCount=Math.max(maxCount,count);
                count=1;
            }
        }
        maxCount=Math.max(maxCount,count);

        return boolCountCheck==true ? maxCount : 0;
    }
}
